/******************************************************************************
    Mapping Consumersâ€™ Context-Dependent Consumption Preferences: 
    A Multidimensional Unfolding Approach 
    (3rd revision, Journal of Consumer Resesarch)

    Update: 2019.09.15 (context.dependent.preference@gmail.com)
    Keywords: Context-dependent preference, multiple ideal points, factor structure approach, 
                 context-dependent multidimensional unfolding (CDMDU) model, context-dependent iso-preference contours
******************************************************************************   
******************************************************************************/

/******************************************************************************
 0. Getting Started
- GAUSS 3.2.8+ is required to use a set of procedures
- libeary co
  : This enables GAUSS to find the CONSTRAINED OPTIMIZATION(co) procedures.                                  
******************************************************************************/
new ;
library co; 
coset;

/******************************************************************************
 1. Data upload      
- We create sample data that is a total of 5,327 consumption occasions by 500 households. 
- We consider a this set that has 10 brands (J=10) and 5 contexts (S=5) 
   where we seek to project preferences onto a K-dimensional attribute space (K=2, 2-segment) for each consumer segment. 
******************************************************************************/

load dta[5327,79] = toy_data.txt ;
n = rows(dta) ;
nbr = 11 ; /* the number of brand is 10 + composite */
id = dta[.,1] ;
br = dta[.,4] ;
choi = dta[.,14:23]~(1-sumc(dta[.,14:23]')) ; /* brand choice */
chois = dta[.,79] ; /* consumption contexts */

context = dta[.,28:31] ; /* (base context is 4) */
context = context[.,1:3]~(1-sumc(context'))~context[.,4] ;/* 4 types consumption contexts (without context 1) */
lad = dta[.,35:45] ; /* local advertisement */
nad = dta[.,46:56] ; /* network TV advertisement */

id = delif(id, sumc(context').==0) ;
choi = delif(choi, sumc(context').==0) ;
n = rows(context) ; /* 5,327 consumption occasions */

ii = 1 ;
np = 1 ; /* 500 households */
pid = id[1,1] ;
do until ii == n+1 ;
	if id[ii,1] ne pid ;
		np = np+1 ;
        pid = id[ii,1] ;
	endif ;
	ii = ii+1 ;
endo ; 

clear p, scen, hh, ns, nd, rr, pp ;

hh = np ; /* 500 households */
ns = 2 ; /* 2 segments */
p = zeros(n, ns) ;
scen = zeros(np, ns) ;

/******************************************************************************
 2. Set the random draws - REROADED                                     
******************************************************************************/

nd = 30 ; /* the number of draws for simulated MLE */
load het[468450,2] = het_new_max16.txt ; /* n by nd*2 matrix (15615*100 by 2) */

/******************************************************************************
 3. Make temp_het1 and temp_het2                                     
******************************************************************************/

/* temp_het1 and temp_het2 are n by nd*25 matrix (15615 by 750) */
temp_het1 = reshape(het[.,1],n,nd)~reshape(het[.,1],n,nd)~reshape(het[.,1],n,nd)~reshape(het[.,1],n,nd)~reshape(het[.,1],n,nd) ;
temp_het2 = reshape(het[.,2],n,nd)~reshape(het[.,2],n,nd)~reshape(het[.,2],n,nd)~reshape(het[.,2],n,nd)~reshape(het[.,2],n,nd) ;

temp_co = context*~ones(n,nd) ; 
temp_ones =  ones(5,1).*.eye(nd) ;
temp_one = ones(n,nd) ;

/***************************************************************************************
 4. Set utility function (factor structure approach) to estimate mean values of weights                                   
****************************************************************************************/
/* procedure for log likelihood function calculation */

clear temp_nhet_1, temp_nhet_2, temp_nhet_3, temp6, temp7, temp8, vcv1, nhet_2 ; 
clear e, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, ch1, ch2 ;
clear e_con1, e1_con1, e2_con1, e3_con1, e4_con1, e5_con1, e6_con1, e7_con1, e8_con1, e9_con1, e10_con1, e11_con1, ch1_con1, ch2_con1 ;
clear hll, lnp, ss, kk, ppp, pp, ii, nhet, zzz, loc1, loc2, loc, ideal1, ideal2, ideal, temp1, temp2 ;

proc fct(x) ;
    temp_nhet_1 = ((x[1]|x[2]|x[3]|x[4]|(ln(2))^(1/2))'.*.temp_one).*temp_het1 + (x[9]|x[10]|x[11]|x[12]|(-ln(2)/2))'.*.temp_one ;     
    temp_nhet_2 = ((x[5]|x[6]|x[7]|x[8]|(ln(2))^(1/2))'.*.temp_one).*temp_het2 + (x[13]|x[14]|x[15]|x[16]|(-ln(2)/2))'.*.temp_one ;  
    temp6 = (temp_co.*exp(temp_nhet_1))*temp_ones ;   
    temp7 = (temp_co.*exp(temp_nhet_2))*temp_ones ;   
    temp8 = (temp_co.*exp(temp_nhet_2))*temp_ones ;
    
    temp1 = x[17] ;
    temp2 = x[18] ;
 
/* segment 1 */
    loc1 = (x[29:38]|0)~(x[39:47]|0|0)~(x[48:55]|0|0|0) ;   
    ideal1 = (x[83:86]|0)~(x[87:90]|0)~(x[91:94]|0) ;

    loc = loc1 ;
    ideal = ideal1 ;        
    
    e1 = exp( x[19] - ((loc[1,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[1,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[1,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,1].*temp1 + nad[.,1].*temp2 ) ;
    e2 = exp( x[20] - ((loc[2,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[2,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[2,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,2].*temp1 + nad[.,2].*temp2 ) ;
    e3 = exp( x[21] - ((loc[3,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[3,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[3,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,3].*temp1 + nad[.,3].*temp2 ) ;
    e4 = exp( x[22] - ((loc[4,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[4,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[4,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,4].*temp1 + nad[.,4].*temp2 ) ;
    e5 = exp( x[23] - ((loc[5,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[5,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[5,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,5].*temp1 + nad[.,5].*temp2 ) ;
    e6 = exp( x[24] - ((loc[6,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[6,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[6,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,6].*temp1 + nad[.,6].*temp2 ) ;
    e7 = exp( x[25] - ((loc[7,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[7,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[7,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,7].*temp1 + nad[.,7].*temp2 ) ;
    e8 = exp( x[26] - ((loc[8,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[8,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[8,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,8].*temp1 + nad[.,8].*temp2 ) ;
    e9 = exp( x[27] - ((loc[9,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[9,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[9,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,9].*temp1 + nad[.,9].*temp2 ) ;
    e10 = exp( x[28] - ((loc[10,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[10,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[10,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,10].*temp1 + nad[.,10].*temp2 ) ;
    e11 = exp(0 - ((0 - ideal[chois[.,1],1])^2).*temp6 - ((0 - ideal[chois[.,1],2])^2).*temp7 - ((0 - ideal[chois[.,1],3])^2).*temp8 + lad[.,11].*temp1 + nad[.,11].*temp2 ) ;
    
    e = e1+e2+e3+e4+e5+e6+e7+e8+e9+e10+e11 ;
    ch1 = (choi[.,1].*(e1./e)) + (choi[.,2].*(e2./e)) + (choi[.,3].*(e3./e)) + (choi[.,4].*(e4./e)) + (choi[.,5].*(e5./e)) + (choi[.,6].*(e6./e)) + (choi[.,7].*(e7./e)) + (choi[.,8].*(e8./e)) + (choi[.,9].*(e9./e)) + (choi[.,10].*(e10./e)) + (choi[.,11].*(e11./e)) ;

/* segment 2 */
    loc2 = (x[56:65]|0)~(x[66:74]|0|0)~(x[75:82]|0|0|0) ;
    ideal2 = (x[95:98]|0)~(x[99:102]|0)~(x[103:106]|0) ;

    loc = loc2 ;
    ideal = ideal2 ;        
    
    e1 = exp( x[19] - ((loc[1,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[1,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[1,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,1].*temp1 + nad[.,1].*temp2 ) ;
    e2 = exp( x[20] - ((loc[2,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[2,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[2,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,2].*temp1 + nad[.,2].*temp2 ) ;
    e3 = exp( x[21] - ((loc[3,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[3,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[3,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,3].*temp1 + nad[.,3].*temp2 ) ;
    e4 = exp( x[22] - ((loc[4,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[4,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[4,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,4].*temp1 + nad[.,4].*temp2 ) ;
    e5 = exp( x[23] - ((loc[5,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[5,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[5,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,5].*temp1 + nad[.,5].*temp2 ) ;
    e6 = exp( x[24] - ((loc[6,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[6,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[6,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,6].*temp1 + nad[.,6].*temp2 ) ;
    e7 = exp( x[25] - ((loc[7,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[7,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[7,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,7].*temp1 + nad[.,7].*temp2 ) ;
    e8 = exp( x[26] - ((loc[8,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[8,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[8,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,8].*temp1 + nad[.,8].*temp2 ) ;
    e9 = exp( x[27] - ((loc[9,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[9,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[9,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,9].*temp1 + nad[.,9].*temp2 ) ;
    e10 = exp( x[28] - ((loc[10,1] - ideal[chois[.,1],1])^2).*temp6 - ((loc[10,2] - ideal[chois[.,1],2])^2).*temp7 - ((loc[10,3] - ideal[chois[.,1],3])^2).*temp8 + lad[.,10].*temp1 + nad[.,10].*temp2 ) ;
    e11 = exp(0 - ((0 - ideal[chois[.,1],1])^2).*temp6 - ((0 - ideal[chois[.,1],2])^2).*temp7 - ((0 - ideal[chois[.,1],3])^2).*temp8 + lad[.,11].*temp1 + nad[.,11].*temp2 ) ;
     
    e = e1+e2+e3+e4+e5+e6+e7+e8+e9+e10+e11 ;
    ch2 = (choi[.,1].*(e1./e)) + (choi[.,2].*(e2./e)) + (choi[.,3].*(e3./e)) + (choi[.,4].*(e4./e)) + (choi[.,5].*(e5./e)) + (choi[.,6].*(e6./e)) + (choi[.,7].*(e7./e)) + (choi[.,8].*(e8./e)) + (choi[.,9].*(e9./e)) + (choi[.,10].*(e10./e)) + (choi[.,11].*(e11./e)) ;
    
    ss = (exp(x[107])|1) ; 
    ss = ss/sumc(ss) ;

    hll = zeros(np,ns) ;
    kk = 1 ;
    ppp = 1 ;
    pp = id[1,1] ;
    ii = 1 ;
    do until ii == n+1 ;
        if id[ii,1] ne pp ;
            hll[ppp,1] = ln(meanc((((prodc(ch1[kk:ii-1,.])))))) ;
            hll[ppp,2] = ln(meanc((((prodc(ch2[kk:ii-1,.])))))) ;
            kk = ii ;
            ppp= ppp+1 ;
            pp = id[ii,1] ;
        endif ;
        if ii == n ;            
            hll[ppp,1] = ln(meanc((((prodc(ch1[kk:ii-1,.])))))) ;
            hll[ppp,2] = ln(meanc((((prodc(ch2[kk:ii-1,.])))))) ;
        endif ;
        ii = ii+1 ;
    endo ;
    zzz = x ;

    lnp = ln(exp(hll)*ss) ;
    retp(-sumc(lnp)) ; 
endp;

/***************************************************************************************
 5. Constraints                      
****************************************************************************************/

proc ineqp(x);
   retp((2.70)*ones(8,1) - (x[1]|x[2]|x[3]|x[4]|x[5]|x[6]|x[7]|x[8])) ;
   retp((x[1]|x[2]|x[3]|x[4]|x[5]|x[6]|x[7]|x[8]) - (1e-5)*ones(8,1)) ;
endp;

_co_IneqProc = &ineqp ;
_co_Options = { BFGS STEPBT TRUST FORWARD FILE } ; /* 1 BFGS, 2 DFP, 3 NEWTON, 4 scaled BFGS, 5 scaled DFP */

/**************************************************************************************
 6. Print estimate results                             
***************************************************************************************/
/* load x0[107,1] = x0_ln_107.txt ; */ 
x0 = (0.001)*ones(107,1) ; 

output file = context_normal_co_new_(K3).out on ;
{ x,f,g,retcode } = co(&fct,x0) ; /* {x,f,g,retcode} = optprt(optmum(&lpr,x0)) */
call coprt(x,f,g,retcode) ;

print ;
2*fct(x)+rows(x)*ln(n) ;

output off ;
end ;

